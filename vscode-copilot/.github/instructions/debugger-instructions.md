---
applyTo: "logs/**/*.md, src/**/*.py, tests/**/*.py"
description: "Automatische Validierungs- und Qualit√§tsregeln f√ºr Debugging"
autoLoad: true
---

# Debugger - Validation & Quality Rules

Diese Instructions werden **automatisch** angewendet beim Arbeiten mit Error Logs und Debugging. Sie erg√§nzen den Debugger Chatmode mit spezifischen Validierungs- und Quality-Checks.

> **Wichtig:** Diese Regeln gelten zus√§tzlich zu `.github/chatmodes/debugger.chatmode.md`

## üìÅ Unterst√ºtzte Dateitypen

Diese Validierungsregeln greifen bei:

```
‚úÖ logs/ERROR-TASK-*.md (Error Logs)
‚úÖ src/**/*.py (Source Code - beim Fixen)
‚úÖ tests/**/*.py (Test Files - beim Aktualisieren)
‚úÖ Beliebige Code-Dateien beim Debugging
```

---

## üîç Automatische Validierungen

### 1. Error Log Format Validation

**Pattern-Validierung beim Lesen:**

```javascript
// Automatischer Check
const errorLogPattern = /^ERROR-TASK-\d{3}-\d{3}-\d{4}-\d{2}-\d{2}-\d{4}\.md$/;

// Beispiel:
// ERROR-TASK-001-001-2025-10-07-1430.md
```

**Required Sections im Error Log:**

```markdown
MANDATORY Sections (beim Lesen):

‚úÖ ## Task Information
   - Task ID
   - Task Title  
   - Date
   - Developer

‚úÖ ## Error Summary
   - Failed Tests count
   - Test Type
   - Severity

‚úÖ ## Test Failures
   F√ºr jeden Test:
   - Test Name
   - File Path
   - Status
   - Error Message
   - Stack Trace
   - Context

‚úÖ ## Code Context
   - Implementation File
   - Relevant Code Section
   - Test Code

‚úÖ ## Environment Information
   - Language/Runtime Version
   - Test Framework
   - Dependencies
   - System

‚úÖ ## Attempted Solutions (optional)
   - What was tried
   - Results
```

**Fehlermeldung bei ung√ºltigem Error Log:**

```
‚ùå Error Log Format ung√ºltig

Datei: logs/error-task-1.md
Problem: Dateiname entspricht nicht Pattern

Korrekt w√§re: ERROR-TASK-001-001-2025-10-07-1430.md

Format:
  ERROR-TASK-{FEATURE-ID}-{TASK-NUM}-{YYYY-MM-DD}-{HHMM}.md
  
Beispiel:
  ERROR-TASK-001-001-2025-10-07-1430.md
```

**Fehlermeldung bei fehlenden Sections:**

```
‚ùå Error Log unvollst√§ndig

Datei: ERROR-TASK-001-001-2025-10-07-1430.md
Status: 4/6 Required Sections vorhanden

Fehlende Sections:
  ‚ùå ## Code Context
  ‚ùå ## Environment Information

Action erforderlich:
  Developer muss Error Log vervollst√§ndigen.
  Debugger kann nicht ohne vollst√§ndige Info arbeiten.
  
Template: .github/templates/ERROR-LOG-TEMPLATE.md
```

---

### 2. Root Cause Analysis Validation

**Mandatory Analysis Documentation:**

```markdown
CHECK w√§hrend Phase 2:

‚úÖ Stack Trace Analysis vorhanden?
‚úÖ Code Inspection dokumentiert?
‚úÖ Test Analysis dokumentiert?
‚úÖ Root Cause Category assigned?
‚úÖ Root Cause != Symptom?
‚úÖ Impact Analysis vorhanden?

VERBOTEN:
‚ùå "Error is in line X" ohne Erkl√§rung WARUM
‚ùå "Fix is to change Y" ohne Root Cause
‚ùå Symptom-Beschreibung statt Root Cause
‚ùå Vage Aussagen wie "something is wrong"
```

**Root Cause Analysis Document Format:**

```markdown
# Root Cause Analysis: TASK-XXX

## Error Summary
- **Test:** [specific test name]
- **Error:** [specific error type and message]
- **Category:** [Logic Error | Type Error | etc.]

## Stack Trace Analysis
1. Error originated in: [file:line]
2. Function called from: [file:line]
3. Propagated through: [call chain]

## Root Cause
**THE REAL PROBLEM:**
[Clear, specific explanation of WHY error occurs]
[Not WHAT error is, but WHY it happens]

**Why Developer's Fix Didn't Work:**
[If applicable, explain why attempted fix failed]

## Impact Analysis
- Affects: [scope of impact]
- Severity: [High | Medium | Low]
- Regression Risk: [High | Medium | Low]
```

**Fehlermeldung bei schlechter Analyse:**

```
‚ö†Ô∏è Root Cause Analysis unzureichend

Datei: ROOT-CAUSE-ANALYSIS-TASK-XXX.md
Probleme gefunden: 3

1. ‚ùå Root Cause zu vage
   Gefunden: "Error in function"
   Ben√∂tigt: Spezifische Erkl√§rung WARUM Fehler auftritt
   
   Beispiel (gut):
   "Function doesn't handle discount=None case. When None 
    is passed, it attempts arithmetic on None, causing TypeError."

2. ‚ùå Missing Stack Trace Analysis
   Section existiert, aber enth√§lt nur "Error in line 45"
   Ben√∂tigt: Vollst√§ndige Call-Chain-Analyse
   
3. ‚ùå Root Cause = Symptom
   Gefunden: "Test fails with AssertionError"
   Problem: Das ist der Symptom, nicht Root Cause
   Ben√∂tigt: WARUM kommt es zu diesem AssertionError?

Action erforderlich:
  Vertiefe Analyse:
  1. Lies Stack Trace von BOTTOM nach TOP
  2. Identifiziere ERSTE Fehlerquelle
  3. Erkl√§re WARUM Code dort versagt
  4. Unterscheide Symptom vs Root Cause
```

---

### 3. Fix Strategy Validation

**Mandatory Strategy Documentation:**

```markdown
CHECK w√§hrend Phase 3:

‚úÖ Mindestens 2 Options betrachtet?
‚úÖ Chosen Option mit Rationale?
‚úÖ Test Strategy definiert?
‚úÖ Regression Prevention geplant?
‚úÖ Implementation Steps klar?

VERBOTEN:
‚ùå Nur eine Option ohne Alternativen
‚ùå "Quick fix" ohne Strategie
‚ùå Workaround als "Fix"
‚ùå Keine Test Strategy
```

**Fix Strategy Document Format:**

```markdown
# Fix Strategy: TASK-XXX

## Root Cause (Recap)
[One-line summary from Phase 2]

## Proposed Fix
**Option 1: [Name] (CHOSEN)**
```python
[Code example]
```

**Why Option 1:**
- [Reason 1]
- [Reason 2]

**Option 2: [Name]**
```python
[Code example]
```

**Why NOT Option 2:**
- [Reason 1]
- [Reason 2]

## Test Strategy
1. [Test update/addition 1]
2. [Test update/addition 2]

## Regression Prevention
- [Prevention measure 1]
- [Prevention measure 2]

## Implementation Steps
1. [Step 1]
2. [Step 2]
```

**Fehlermeldung bei schlechter Strategie:**

```
‚ùå Fix Strategy unvollst√§ndig

Datei: FIX-STRATEGY-TASK-XXX.md
Status: 3/5 Required Sections vorhanden

Probleme:

1. ‚ùå Nur eine Option
   Gefunden: Option 1 only
   Ben√∂tigt: Min. 2 Options mit Pros/Cons
   
   ‚Üí Betrachte Alternativen:
     - Default Parameter
     - Explicit None Handling
     - Validation at API Layer
     - Type Narrowing

2. ‚ùå Test Strategy fehlt
   Keine Test-Planung dokumentiert
   
   ‚Üí Definiere:
     - Welche Tests zu aktualisieren?
     - Welche Tests neu hinzuzuf√ºgen?
     - Edge Cases abzudecken?

3. ‚ùå Regression Prevention fehlt
   Keine Ma√ünahmen gegen Regressionen
   
   ‚Üí Plane:
     - ALL tests run
     - Coverage check
     - Integration test verification

Action erforderlich:
  Vervollst√§ndige Fix Strategy vor Implementation!
```

---

### 4. Fix Implementation Quality

**Code Quality Checks:**

```markdown
CHECK w√§hrend Phase 4:

‚úÖ Type Hints vorhanden?
‚úÖ Docstrings aktualisiert?
‚úÖ Input Validation hinzugef√ºgt?
‚úÖ Error Handling proper?
‚úÖ No Workarounds?
‚úÖ Clean Code Principles?
‚úÖ No TODOs in Fix?

VERBOTEN:
‚ùå try-catch ohne proper logging
‚ùå Hardcoded values
‚ùå Magic numbers
‚ùå Commented-out code
‚ùå print() statements (use logging)
```

**Beispiel - SCHLECHTER Fix:**

```python
# ‚ùå BAD FIX
def calculate_price(base, discount):
    try:
        return base - (base * discount)  # No validation
    except:  # Bare except
        return 0  # Loses information
```

**Beispiel - GUTER Fix:**

```python
# ‚úÖ GOOD FIX
def calculate_price(
    base_price: float,  # Type hint
    discount: float = 0.0  # Default parameter
) -> float:  # Return type hint
    """
    Calculate final price with optional discount.
    
    Args:
        base_price: Original price (must be positive)
        discount: Discount percentage 0-100 (default: 0.0)
        
    Returns:
        Final price after discount
        
    Raises:
        ValueError: If inputs invalid
        
    Examples:
        >>> calculate_price(100.0, 10.0)
        90.0
    """
    # Input validation
    if base_price < 0:
        raise ValueError("Base price must be positive")
    if discount < 0 or discount > 100:
        raise ValueError("Discount must be between 0 and 100")
    
    # Clean calculation
    return base_price * (1 - discount / 100)
```

**Fehlermeldung bei schlechtem Fix:**

```
‚ö†Ô∏è Fix Implementation Quality Issues

Datei: src/pricing.py
Function: calculate_price
Probleme: 4

1. ‚ùå Missing Type Hints
   Gefunden: def calculate_price(base, discount):
   Fix: def calculate_price(base_price: float, discount: float = 0.0) -> float:

2. ‚ùå No Input Validation
   Problem: Function accepts any value without checking
   Fix: Add validation for negative/invalid inputs

3. ‚ùå Bare except clause
   Gefunden: except:
   Fix: except SpecificException as e: + proper logging

4. ‚ùå Missing Docstring
   Problem: No documentation for function behavior
   Fix: Add comprehensive docstring with examples

Action erforderlich:
  Refactor Fix gem√§√ü Clean Code Principles.
  Siehe Best Practice Examples in debugger.chatmode.md
```

---

### 5. Test Update/Addition Validation

**Test Quality Checks:**

```markdown
CHECK w√§hrend Phase 4:

‚úÖ Affected tests updated?
‚úÖ Edge case tests added?
‚úÖ Happy path tested?
‚úÖ Error cases tested?
‚úÖ Parametrized tests f√ºr multiple scenarios?
‚úÖ Test names descriptive?
‚úÖ Docstrings in tests?

MINIMUM Test Coverage:
‚úÖ 1x Happy Path Test
‚úÖ 1x Edge Case Test
‚úÖ 1x Error Case Test
‚úÖ 1x Parametrized Test (if applicable)
```

**Test Quality Example - BAD:**

```python
# ‚ùå BAD TESTS
def test_price():
    assert calculate_price(100, 10) == 90
    
def test_price2():
    assert calculate_price(100) == 100
```

**Test Quality Example - GOOD:**

```python
# ‚úÖ GOOD TESTS
class TestPriceCalculation:
    """Tests for price calculation with discount."""
    
    def test_price_with_valid_discount(self):
        """Test normal discount application."""
        result = calculate_price(100.0, 10.0)
        assert result == 90.0
    
    def test_price_without_discount_parameter(self):
        """Test default discount behavior."""
        result = calculate_price(100.0)
        assert result == 100.0
    
    def test_price_with_zero_discount(self):
        """Test explicit zero discount."""
        result = calculate_price(100.0, 0.0)
        assert result == 100.0
    
    def test_price_with_invalid_negative_discount(self):
        """Test error handling for negative discount."""
        with pytest.raises(ValueError, match="between 0 and 100"):
            calculate_price(100.0, -10.0)
    
    @pytest.mark.parametrize("base,discount,expected", [
        (100.0, 10.0, 90.0),
        (100.0, 20.0, 80.0),
        (50.0, 50.0, 25.0),
    ])
    def test_various_discount_scenarios(self, base, discount, expected):
        """Test multiple discount scenarios."""
        assert calculate_price(base, discount) == expected
```

**Fehlermeldung bei unzureichenden Tests:**

```
‚ö†Ô∏è Test Coverage unzureichend

Datei: tests/unit/test_pricing.py
Function: calculate_price
Probleme: 3

1. ‚ùå Nur 2 Tests f√ºr Fix
   Gefunden: test_price, test_price2
   Minimum: 4 Tests (Happy, Edge, Error, Parametrized)
   
   Fehlende Tests:
   - test_price_with_invalid_discount()
   - test_price_with_boundary_values()
   - test_various_discount_scenarios() (parametrized)

2. ‚ùå Test Namen nicht beschreibend
   test_price, test_price2 sind zu generisch
   
   ‚Üí Nutze beschreibende Namen:
     test_price_with_valid_discount
     test_price_without_discount_parameter

3. ‚ùå Keine Docstrings in Tests
   Tests sollten dokumentieren WAS sie testen
   
   ‚Üí F√ºge Docstrings hinzu:
     """Test normal discount application."""

Action erforderlich:
  Erweitere Test Suite um fehlende Cases.
  Minimum: 4 Tests mit klaren Namen und Docstrings.
```

---

### 6. Comprehensive Testing Validation (CRITICAL)

**MANDATORY: ALL Tests m√ºssen ausgef√ºhrt werden!**

```markdown
CHECK w√§hrend Phase 5:

‚úÖ Affected tests run?
‚úÖ ALL unit tests run?
‚úÖ ALL integration tests run?
‚úÖ Coverage check run?
‚úÖ Linter run?
‚úÖ Type checker run (if applicable)?
‚úÖ NO new failures?
‚úÖ Coverage maintained (>90%)?

VERBOTEN:
‚ùå Nur betroffene Tests run
‚ùå Skip integration tests
‚ùå Ignore coverage drop
‚ùå "Tests probably pass"
‚ùå Proceed without running ALL tests
```

**Test Execution Evidence Required:**

```bash
# Evidence Format (in Resolution)
Test Results:
‚úÖ Unit Tests: 134/134 passed (+7 new)
‚úÖ Integration Tests: 45/45 passed
‚úÖ Coverage: 94% (maintained, was 92%)
‚úÖ Linter: 0 issues
‚úÖ Type Check: Success

Test Commands Run:
$ pytest tests/unit/ -v
$ pytest tests/integration/ -v
$ pytest tests/ --cov=src --cov-report=term
$ flake8 src/ tests/
$ mypy src/
```

**Fehlermeldung bei unvollst√§ndigem Testing:**

```
‚ùå CRITICAL: Comprehensive Testing nicht durchgef√ºhrt

Problem: Nur affected tests wurden run

MANDATORY Requirements:
- [ ] ‚ùå ALL unit tests run
- [ ] ‚ùå ALL integration tests run
- [ ] ‚ùå Coverage check performed
- [x] ‚úÖ Affected tests run (insufficient!)

Action erforderlich:
  Run COMPLETE test suite:
  
  1. pytest tests/unit/ -v
  2. pytest tests/integration/ -v
  3. pytest tests/ --cov=src --cov-report=term
  4. Verify NO new failures
  5. Verify coverage maintained >90%

UNTIL ALL tests run, fix is NOT validated!
```

**Regression Detection:**

```markdown
CHECK f√ºr Regressions:

‚úÖ Alle bisherigen Tests noch passing?
‚úÖ Keine neuen Failures?
‚úÖ Coverage nicht gesunken?
‚úÖ Keine Breaking Changes?

Wenn Regression gefunden:
‚ùå STOP immediately
‚ùå DO NOT proceed to Phase 6
‚ùå Analyze regression cause
‚ùå Fix regression
‚ùå Re-run ALL tests (Phase 5 again)
```

**Fehlermeldung bei Regression:**

```
‚ùå REGRESSION DETECTED!

Phase 5 Test Results:
- Unit Tests: 132/134 passed (2 NEW FAILURES!)
- Failed Tests:
  * test_order_total_calculation ‚ùå
  * test_checkout_flow ‚ùå

Analysis:
Both failures related to calculate_price() signature change.
Dependent functions calling with positional args now fail.

Impact: HIGH - Breaks order processing

Action erforderlich:
1. STOP current fix process
2. Analyze regression cause:
   - Search ALL callers of calculate_price()
   - Identify breaking changes
3. Fix regression:
   - Update callers to use named parameters OR
   - Maintain backward compatibility
4. Re-run Phase 5 (ALL tests)
5. Only proceed to Phase 6 if ALL tests pass

DO NOT proceed without fixing regression!
```

---

### 7. Error Log Resolution Validation

**Resolution Section Required:**

```markdown
CHECK am Ende von Phase 6:

‚úÖ Resolution Section im Error Log?
‚úÖ Status: RESOLVED gesetzt?
‚úÖ Root Cause dokumentiert?
‚úÖ Fix Applied mit Code dokumentiert?
‚úÖ Tests Updated dokumentiert?
‚úÖ Test Results dokumentiert?
‚úÖ Learnings dokumentiert?
‚úÖ Prevention Strategy dokumentiert?
‚úÖ Verification Checklist complete?

Resolution Section Format:
---
## ‚úÖ RESOLUTION

**Status:** RESOLVED
**Resolved By:** Debugger Mode
**Resolution Date:** YYYY-MM-DD HH:MM
**Time to Resolve:** XX minutes

### Root Cause
[Clear explanation]

### Fix Applied
**File:** [path]
**Changes:** [list]
**Code:** [code block]

### Tests Updated
**File:** [path]
**Added/Updated Tests:** [list]
**Test Results:** [results]

### Learnings
1. [Learning 1]
2. [Learning 2]

### Prevention Strategy
- [Strategy 1]
- [Strategy 2]

### Verification
- [x] Original error resolved
- [x] All tests passing
- [x] No regressions
- [x] Coverage maintained
```

**Fehlermeldung bei unvollst√§ndiger Resolution:**

```
‚ùå Error Log Resolution unvollst√§ndig

Datei: ERROR-TASK-001-001-2025-10-07-1430.md
Status: 6/9 Resolution Sections vorhanden

Fehlende Sections:
  ‚ùå ### Prevention Strategy
  ‚ùå ### Verification Checklist
  ‚ùå ### Learnings

Action erforderlich:
  Vervollst√§ndige Resolution Section:
  
  1. Dokumentiere Learnings:
     Was haben wir aus diesem Fehler gelernt?
  
  2. Dokumentiere Prevention Strategy:
     Wie verhindern wir √§hnliche Fehler zuk√ºnftig?
  
  3. Complete Verification Checklist:
     - [ ] Original error resolved
     - [ ] All tests passing
     - [ ] No regressions
     - [ ] Coverage maintained
     - [ ] Documentation updated

Resolution ist NICHT complete ohne diese Sections!
```

---

### 8. Commit Message Validation

**Commit Message Format Required:**

```markdown
CHECK vor Commit:

‚úÖ Type correct? (fix|docs|test)
‚úÖ Scope present? (module/component)
‚úÖ Root Cause documented?
‚úÖ Fix Applied documented?
‚úÖ Testing documented?
‚úÖ References Error Log?
‚úÖ Time to Fix documented?

Format:
fix(scope): brief description

Root Cause:
- Point 1
- Point 2

Fix Applied:
- Change 1
- Change 2

Testing:
- Test results
- Coverage info

Resolves: ERROR-TASK-XXX-YYYY-MM-DD-HHMM
Related: TASK-XXX
Time to Fix: XX minutes
```

**Beispiel - SCHLECHTE Commit Message:**

```
‚ùå BAD:
"fixed bug"

Problem: Keine Information!
```

**Beispiel - GUTE Commit Message:**

```
‚úÖ GOOD:
fix(pricing): handle optional discount parameter correctly

Root Cause:
- calculate_price() didn't handle discount=None
- Missing input validation
- No default parameter

Fix Applied:
- Added default parameter: discount=0.0
- Added type hints for clarity
- Added input validation (0-100 range)
- Added proper error handling

Testing:
- Added 7 new test cases
- All edge cases covered
- 134/134 tests passing
- Coverage maintained at 94%

Resolves: ERROR-TASK-001-001-2025-10-07-1430
Related: TASK-001-001
Time to Fix: 45 minutes
```

**Fehlermeldung bei schlechter Commit Message:**

```
‚ö†Ô∏è Commit Message unzureichend

Gefunden: "fixed bug"

Probleme:
1. ‚ùå Kein Typ (fix|docs|test)
2. ‚ùå Kein Scope
3. ‚ùå Kein Root Cause
4. ‚ùå Kein Fix Applied
5. ‚ùå Keine Testing Info
6. ‚ùå Keine References

Action erforderlich:
  Schreibe informative Commit Message:
  - WAS war das Problem? (Root Cause)
  - WIE wurde es gel√∂st? (Fix Applied)
  - WIE wurde es validiert? (Testing)
  - WELCHER Error Log? (References)

Template: .github/templates/COMMIT-MESSAGE-TEMPLATE.txt
```

---

## üìä Quality Gate Checks

**Pre-Commit Validation:**

```markdown
QGD (Quality Gate Debugging) Check:

‚úÖ Error Log vollst√§ndig gelesen?
‚úÖ Root Cause Analysis vollst√§ndig?
‚úÖ Fix Strategy mit 2+ Options?
‚úÖ Fix Implementation clean?
‚úÖ Tests updated/added (min. 4)?
‚úÖ ALL Tests run und passing?
‚úÖ Coverage maintained (>90%)?
‚úÖ NO Regressions?
‚úÖ Error Log Resolution complete?
‚úÖ Commit Message informative?

Wenn ALLE ‚úÖ:
  ‚Üí Commit allowed
  ‚Üí Notify Developer

Wenn EIN ‚ùå:
  ‚Üí BLOCK Commit
  ‚Üí Show specific failure
  ‚Üí Require fix
```

**Quality Gate Report Format:**

```
üîç QGD (Quality Gate Debugging) Check

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Phase 1: Error Log Analysis           ‚îÇ
‚îÇ ‚úÖ Error Log format valid              ‚îÇ
‚îÇ ‚úÖ All required sections present       ‚îÇ
‚îÇ ‚úÖ Context fully understood            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Phase 2: Root Cause Analysis          ‚îÇ
‚îÇ ‚úÖ Stack Trace analyzed                ‚îÇ
‚îÇ ‚úÖ Root Cause identified (not symptom) ‚îÇ
‚îÇ ‚úÖ Impact Assessment complete          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Phase 3: Fix Strategy                 ‚îÇ
‚îÇ ‚úÖ 2+ Options considered               ‚îÇ
‚îÇ ‚úÖ Best option chosen with rationale   ‚îÇ
‚îÇ ‚úÖ Test Strategy defined               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Phase 4: Implementation                ‚îÇ
‚îÇ ‚úÖ Fix implemented cleanly             ‚îÇ
‚îÇ ‚úÖ Type hints added                    ‚îÇ
‚îÇ ‚úÖ Input validation added              ‚îÇ
‚îÇ ‚úÖ Tests updated/added (7 new)         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Phase 5: Testing                       ‚îÇ
‚îÇ ‚úÖ ALL unit tests: 134/134 passing     ‚îÇ
‚îÇ ‚úÖ ALL integration tests: 45/45 passing‚îÇ
‚îÇ ‚úÖ Coverage: 94% (maintained)          ‚îÇ
‚îÇ ‚úÖ NO Regressions detected             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Phase 6: Documentation                 ‚îÇ
‚îÇ ‚úÖ Error Log Resolution complete       ‚îÇ
‚îÇ ‚úÖ Learnings documented                ‚îÇ
‚îÇ ‚úÖ Prevention Strategy documented      ‚îÇ
‚îÇ ‚úÖ Commit Message informative          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üéâ QGD PASSED! Ready to Commit & Notify Developer

Next: Commit fix and update BACKLOG.md
```

---

## üö® Critical Validation Rules

**THESE RULES CANNOT BE BYPASSED:**

1. **‚úÖ MANDATORY: ALL Tests Run**
   - Cannot proceed without running ALL tests
   - Not just affected tests
   - Must include integration tests
   - Must include coverage check

2. **‚úÖ MANDATORY: No Regressions**
   - ALL previously passing tests must still pass
   - Coverage must not drop below 90%
   - No new failures allowed

3. **‚úÖ MANDATORY: Root Cause Identified**
   - Cannot fix without understanding WHY
   - Symptom fix is not acceptable
   - Must document Root Cause clearly

4. **‚úÖ MANDATORY: Resolution Documented**
   - Error Log must be updated
   - Resolution Section required
   - Learnings must be captured

5. **‚úÖ MANDATORY: Clean Implementation**
   - No workarounds
   - No TODOs in fix
   - Clean Code Principles followed

---

## üí¨ Validation Message Formats

### Success Format:

```
‚úÖ {PHASE}

Validation successful:
  ‚úÖ {Check 1}
  ‚úÖ {Check 2}
  ‚úÖ {Check 3}

Status: {Status}
Next: {Next Phase}
```

### Warning Format:

```
‚ö†Ô∏è {PHASE}

Quality warnings (non-blocking):
  ‚ö†Ô∏è {Warning 1}
  ‚ö†Ô∏è {Warning 2}

Recommendations:
  1. {Recommendation 1}
  2. {Recommendation 2}

Status: Acceptable but could be improved
```

### Error Format:

```
‚ùå {PHASE}

Validation failed ({X}/{Y} checks passed):
  ‚ùå {Error 1 - specific description}
  ‚ùå {Error 2 - specific description}

Actions required:
  1. {Concrete Action 1}
  2. {Concrete Action 2}

BLOCKED: Cannot proceed until errors fixed
```

---

## üîÑ Integration mit Developer Mode

**Automatic Validation Trigger:**

```
Developer creates Error Log
  ‚Üì
Debugger loads Error Log
  ‚Üì
Automatic validation:
  - Format check
  - Completeness check
  ‚Üì
If validation fails:
  ‚Üí Notify Developer
  ‚Üí Request Error Log fix
  ‚Üí STOP debugging

If validation passes:
  ‚Üí Proceed with debugging
```

---

## üìã Zusammenfassung

Diese Instructions stellen sicher:

‚úÖ **Error Log Quality** - Vollst√§ndige, strukturierte Error Logs  
‚úÖ **Root Cause Analysis** - Systematische Problem-Identifikation  
‚úÖ **Clean Fixes** - Keine Workarounds, echte L√∂sungen  
‚úÖ **Comprehensive Testing** - ALL Tests run, keine Regressions  
‚úÖ **Documentation** - Vollst√§ndige Resolution und Learnings  
‚úÖ **Quality Gates** - Automatic validation vor Commit  

**Ziel:** Stelle sicher, dass JEDER Fix dem Quality-Standard entspricht - systematisch, gr√ºndlich, nachhaltig!

---

**Version:** 1.0  
**Last Updated:** 2025-10-07  
**Integration:** Works with debugger.chatmode.md and developer.chatmode.md